package gpoint

const tests = `
// Code generated by internal/gpoint DO NOT EDIT 
package {{.PackageName}}

import (
	"testing"
	"fmt"
	"github.com/alexeykiselev/gurvy/utils/parallel"
	"github.com/alexeykiselev/gurvy/{{.PackageName}}/fr"
)

func Test{{.Name}}JacToAffineFromJac(t *testing.T) {

	p := testPoints{{.Name}}()

	_p := {{.Name}}Affine{}
	p[0].ToAffineFromJac(&_p)
	if !_p.X.Equal(&p[1].X) || !_p.Y.Equal(&p[1].Y){
		t.Fatal("ToAffineFromJac failed")
	}
	
}

func Test{{.Name}}Conv(t *testing.T) {
	p := testPoints{{.Name}}()

	for i := 0 ; i < len(p) ; i++ {
		var pJac {{.Name}}Jac
		var pAff {{.Name}}Affine
		p[i].ToAffineFromJac(&pAff)
		pAff.ToJacobian(&pJac)
		if !pJac.Equal(&p[i]) {
			t.Fatal("jacobian to affine to jacobian fails")
		}
	}
}


func Test{{.Name}}JacAdd(t *testing.T) {

	curve := {{toUpper .PackageName}}()
	p := testPoints{{.Name}}()

	// p3 = p1 + p2
	p1 := p[1].Clone()
	_p2 := {{.Name}}Affine{}
	p[2].ToAffineFromJac(&_p2)
	p[1].AddMixed(&_p2)
	p[2].Add(curve, p1)

	if !p[3].Equal(&p[1]) {
		t.Fatal("Add failed")
	}

	// test commutativity
	if !p[3].Equal(&p[2]) {
		t.Fatal("Add failed")
	}
}

func Test{{.Name}}JacSub(t *testing.T) {

	curve := {{toUpper .PackageName}}()
	p := testPoints{{.Name}}()

	// p4 = p1 - p2
	p[1].Sub(curve, p[2])

	if !p[4].Equal(&p[1]) {
		t.Fatal("Sub failed")
	}
}

func Test{{.Name}}JacDouble(t *testing.T) {

	curve := {{toUpper .PackageName}}()
	p := testPoints{{.Name}}()

	// p5 = 2 * p1
	p[1].Double()
	if !p[5].Equal(&p[1]) {
		t.Fatal("Double failed")
	}

	G := curve.{{toLower .Name}}Infinity.Clone()
	R := curve.{{toLower .Name}}Infinity.Clone()
	G.Double()

	if !G.Equal(R) {
		t.Fatal("Double failed (infinity case)")
	}
}

func Test{{.Name}}JacScalarMul(t *testing.T) {

	curve := {{toUpper .PackageName}}()
	p := testPoints{{.Name}}()

	// p6 = [p1]32394 (scalar mul)
	scalar := fr.Element{32394}
	p[1].ScalarMul(curve, &p[1], scalar)

	if !p[1].Equal(&p[6]) {
		t.Error("ScalarMul failed")
	}
}

func TestMultiExp{{.Name}}(t *testing.T) {

	curve := {{toUpper .PackageName}}()

	var G {{.Name}}Jac

	// mixer ensures that all the words of a fpElement are set
	var mixer fr.Element
	mixer.SetString("7716837800905789770901243404444209691916730933998574719964609384059111546487")

	samplePoints := make([]{{.Name}}Affine, 3000)
	sampleScalars := make([]fr.Element, 3000)

	G.Set(&curve.{{toLower .Name}}Gen)

	for i := 1; i <= 3000; i++ {
		sampleScalars[i-1].SetUint64(uint64(i)).
			MulAssign(&mixer).
			FromMont()
		G.ToAffineFromJac(&samplePoints[i-1])
		G.Add(curve, &curve.{{toLower .Name}}Gen)
	}

	var testLotOfPoint, testPoint {{.Name}}Jac

	<-testLotOfPoint.MultiExp(curve, samplePoints, sampleScalars)
	<-testPoint.MultiExp(curve, samplePoints[:30], sampleScalars[:30])

	var finalBigScalar fr.Element
	var finalLotOfPoint {{.Name}}Jac
	finalBigScalar.SetString("9004500500").MulAssign(&mixer).FromMont()
	finalLotOfPoint.ScalarMul(curve, &curve.{{toLower .Name}}Gen, finalBigScalar)

	var finalScalar fr.Element
	var finalPoint {{.Name}}Jac
	finalScalar.SetString("9455").MulAssign(&mixer).FromMont()
	finalPoint.ScalarMul(curve, &curve.{{toLower .Name}}Gen, finalScalar)

	if !finalLotOfPoint.Equal(&testLotOfPoint) {
		t.Fatal("error multi (>50 points) exp")
	}
	if !finalPoint.Equal(&testPoint) {
		t.Fatal("error multi <=50 points) exp")
	}

}

`
